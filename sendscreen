#!/usr/bin/env python3
#
# Display local desktop on remove host without VGA/HDMI cable
# Copyright (c) 2019, Hiroyuki Ohsaki.
# All rights reserved.
#
# $Id: pysendscreen,v 1.24 2019/07/07 15:40:21 ohsaki Exp $
#

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import os
import socket
import sys
import time
import zlib

from Xlib import X, display
from perlcompat import die, warn, getopts
import pygame
import pygame.gfxdraw
import pygame.transform
import tbdump

POINTER_COLOR = 255, 255, 0, 128
POINTER_SIZE = 10
FONT_NAME = '/etc/alternatives/fonts-japanese-gothic.ttf'
FONT_SIZE = 20
LABEL_COLOR = 255, 255, 255, 128

def usage():
    die("""\
usage: {} [-vr] [-s host] [-p port] [-W width] [-H height]
  -v       verbose mode
  -r       receiver mode
  -s host  specify receiver hostname/address
  -p port  port number
  -W #     screen width (default: 800)
  -H #     screen height (default: 600)
""".format(sys.argv[0]))

def pointer_geometry(xscreen):
    """Obtain the current geometry of the pointer (i.e., mouse) on screen
    XSCREEN.  This code is contributed by Hal."""
    stat = xscreen.root.query_pointer()
    x, y = stat.root_x, stat.root_y
    return x, y

class Frame:
    def __init__(self, width=800, height=600, user=None, hostname=None):
        self.width = width
        self.height = height
        self.user = user
        self.hostname = hostname
        self.pnt_x = None
        self.pnt_y = None
        self.header = None
        self.img = None
        self.zbuf = None

    def compose_header(self):
        astr = '{} {} {} {} {} {}\n'.format(self.user, self.hostname,
                                            self.width, self.height,
                                            self.pnt_x, self.pnt_y)
        return bytes(astr, encoding='utf-8')

    def dump_root_window(self):
        """Return the rectangle of the root window in RGBX format."""
        xscreen = display.Display().screen()
        img = xscreen.root.get_image(0, 0, self.width, self.height, X.ZPixmap,
                                     0xffffffff)
        # format conversion from BGRX to RGBX
        buf = bytearray(img.data)
        for i in range(0, self.width * self.height * 4, 4):
            buf[i], buf[i + 2] = buf[i + 2], buf[i]  # swap red and blue
        return buf

    def capture(self):
        self.header = self.compose_header()
        # zlib-compressed raw RGBX pixels
        self.img = self.dump_root_window()
        self.zbuf = zlib.compress(self.header + self.img)

    def load(self, zbuf):
        try:
            buf = zlib.decompress(zbuf)
        except zlib.error:
            return None
        try:
            offset = buf.index(b'\n') + 1
        except ValueError:
            return None
        self.header = buf[:offset - 1]
        self.img = buf[offset:]

        # parse frame header
        user, hostname, width, height, pnt_x, pnt_y = self.header.split(b' ')
        self.user = user
        self.hostname = hostname
        self.width = int(width)
        self.height = int(height)
        self.pnt_x = int(pnt_x)
        self.pnt_y = int(pnt_y)

class Sender:
    def __init__(self, server='localhost', port=5000, width=800, height=600):
        self.server = server
        self.port = port
        self.width = width
        self.height = height

    def connect(self):
        warn('connecting to {}:{}...'.format(self.server, self.port))
        self.sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sk.connect((self.server, self.port))

    def send(self, frame):
        warn('  sending frame ({} bytes)...'.format(len(frame.zbuf)))
        try:
            warn('  sendall()...')
            self.sk.sendall(frame.zbuf)
        except ConnectionResetError:
            pass

    def mainloop(self):
        """Repeatedly send the rectangle of the current desktop to remote host
        via TCP."""
        user = os.getenv('USER')
        hostname = socket.gethostname()
        xscreen = display.Display().screen()
        while True:
            try:
                self.connect()
            except ConnectionRefusedError:
                time.sleep(1)  # retry after delay
                continue
            frame = Frame(self.width, self.height, user, hostname)
            frame.pnt_x, frame.pnt_y = pointer_geometry(xscreen)
            frame.capture()
            self.send(frame)

class Receiver:
    def __init__(self, port=5000, width=800, height=600):
        self.port = port
        self.width = width
        self.height = height
        self.ndrawn = 0

    def init_display(self):
        warn('initializing display...')
        # disable screen saver and display power management
        os.system('xset s off')
        os.system('xset -dpms')

        # initialize pygame and create a window
        pygame.display.init()
        pygame.font.init()
        self.screen = pygame.display.set_mode((self.width, self.height))
        self.font = pygame.font.Font(FONT_NAME, FONT_SIZE)

    def recv(self, conn):
        conn.settimeout(5.)
        try:
            warn('  recv()...')
            zbuf = conn.recv(1000_000)
        except socket.timeout:
            return None
        warn('  received frame ({} bytes)...'.format(len(zbuf)))
        frame = Frame()
        frame.load(zbuf)
        return frame

    def draw_img(self, screen, img, width, height):
        """Draw an image IMG at the origin (0, 0) of the current window."""
        try:
            # convert RGBX image to pygame.Surface object
            img = pygame.image.fromstring(img, (width, height), 'RGBX')
        except ValueError:
            return
        screen.blit(img, (0, 0))

    def draw_pointer(self, screen, x, y):
        """Draw a virtual pointer at (X, Y)."""
        pygame.gfxdraw.filled_ellipse(screen, x, y, POINTER_SIZE, POINTER_SIZE,
                                      POINTER_COLOR)

    def draw_label(self, screen, font, label):
        """Draw a text LABEL using font FONT at the upper-right corner of the
        screen SCREEN."""
        text = font.render(label, 1, LABEL_COLOR)
        x = screen.get_width() - text.get_width() - FONT_SIZE // 2
        y = FONT_SIZE // 2
        screen.blit(text, (x, y))

    def draw(self, frame):
        """Draw a frame FRAME at the origin (0, 0) of the current window."""
        self.screen.fill((0, 0, 0))
        self.draw_img(self.screen, frame.img, frame.width, frame.height)
        # blink the pointer as keep-alive indicator
        if self.ndrawn % 2 == 0:
            self.draw_pointer(self.screen, frame.pnt_x, frame.pnt_y)
        self.draw_label(self.screen, self.font,
                        frame.user + b'@' + frame.hostname)
        pygame.display.update()
        self.ndrawn += 1

    def mainloop(self):
        """Repeatedly receive frames from a client, and display the frame in
        the window."""
        self.init_display()
        self.sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sk.bind(('', self.port))  # all available interfaces
        self.sk.listen()
        while True:
            conn, addr = self.sk.accept()
            warn('connected from {}...'.format(addr))
            frame = self.recv(conn)
            if frame and frame.img:
                self.draw(frame)

def main():
    opt = getopts('vrs:p:W:H:') or usage()
    verbose = opt.v
    receiver_mode = opt.r
    server = opt.s if opt.s else 'localhost'
    port = int(opt.p) if opt.p else 5000
    width = int(opt.W) if opt.W else 800
    height = int(opt.H) if opt.H else 600
    if receiver_mode:
        receiver = Receiver(port, width, height)
        receiver.mainloop()
    else:
        sender = Sender(server, port, width, height)
        sender.mainloop()

if __name__ == "__main__":
    main()
